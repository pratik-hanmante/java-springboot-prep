import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

class Main {
    public static void main(String[] args) {

      
       // 1. CREATING COLLECTIONS
       
       
       // Arrays.asList() creates a FIXED-SIZE list (cannot add/remove elements)
       // Wrap it in ArrayList to make it modifiable
       List<String> footballers = new ArrayList<>(Arrays.asList(
        "Marcus Silva", "Leon Bergström", "Diego Fernández", "Thomas Müller", 
        "Alessandro Rossi", "Kevin De Bruyne", "Rafael Santos", "Johan Eriksson", 
        "Antoine Dubois", "Luca Bianchi", "Hiroshi Tanaka", "Miguel Rodríguez", 
        "Pierre Laurent", "Mateo García", "Andreas Schmidt"
       ));

      
       // 2. SORTING OPERATIONS
       
       
       System.out.println("\n=== 1. Sorting Alphabetically (Natural Order) ===");
       // Collections.sort() uses natural ordering (alphabetical for Strings)
       // Time Complexity: O(n log n)
       Collections.sort(footballers);
       footballers.forEach(System.out::println);

       System.out.println("\n=== 2. Sorting Based on Length ===");
       // Custom comparator by using method reference
       // Comparator.comparingInt() creates a comparator based on int values
       Collections.sort(footballers, Comparator.comparingInt(String::length));
       footballers.forEach(System.out::println);

       System.out.println("\n=== 3. Sorting in Reverse Order ===");
       // Collections.reverseOrder() returns a comparator for reverse natural ordering
       footballers.sort(Collections.reverseOrder());
       footballers.forEach(System.out::println);

       System.out.println("\n=== 4. Custom Sorting (By Last Name) ===");
       // Complex comparator: sort by last name (word after space)
       footballers.sort((a, b) -> {
           String lastNameA = a.substring(a.lastIndexOf(" ") + 1);
           String lastNameB = b.substring(b.lastIndexOf(" ") + 1);
           return lastNameA.compareTo(lastNameB);
       });
       footballers.forEach(System.out::println);

// 3. MANIPULATION OPERATIONS


       System.out.println("\n=== 5. Shuffling the Elements ===");
       // Randomly permutes the list - useful for randomizing data
       Collections.shuffle(footballers);
       footballers.forEach(System.out::println);

       System.out.println("\n=== 6. Swapping Elements (First and Last) ===");
       // Swaps elements at two positions - O(1) operation
       Collections.swap(footballers, 0, footballers.size()-1);
       footballers.forEach(System.out::println);

       System.out.println("\n=== 7. Reversing the List ===");
       // Reverses the order of elements in place
       Collections.reverse(footballers);
       footballers.forEach(System.out::println);

       System.out.println("\n=== 8. Rotating Elements ===");
       // Rotates list by specified distance (positive = right, negative = left)
       Collections.rotate(footballers, 3); // Move last 3 elements to front
       footballers.forEach(System.out::println);

      
       // 4. IMMUTABILITY & THREAD-SAFETY
       

       System.out.println("\n=== 9. Creating an Unmodifiable Collection ===");
       // Returns an unmodifiable view - any modification throws UnsupportedOperationException
       // Still FAIL-FAST: throws exception if original list is modified during iteration
       List<String> unmodifiableList = Collections.unmodifiableList(footballers);
       unmodifiableList.forEach(System.out::println);
       
       // Uncommenting below will throw UnsupportedOperationException
       // unmodifiableList.add("New Player"); 
       // unmodifiableList.set(0, "Modified");

       System.out.println("\n=== 10. Synchronized Collection (Thread-Safe) ===");
       // Makes collection thread-safe by wrapping it with synchronized methods
       // All methods are synchronized - performance overhead
       List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>(footballers));
       System.out.println("Created synchronized list with " + synchronizedList.size() + " elements");
       
       // Must manually synchronize when iterating
       synchronized(synchronizedList) {
           synchronizedList.forEach(System.out::println);
       }

       
       // 5. SEARCHING & FINDING
       

       System.out.println("\n=== 11. Finding Max and Min ===");
       // Max/Min based on natural ordering or custom comparator
       String longestName = Collections.max(footballers, Comparator.comparingInt(String::length));
       String shortestName = Collections.min(footballers, Comparator.comparingInt(String::length));
       System.out.println("Longest Name: " + longestName);
       System.out.println("Shortest Name: " + shortestName);

       System.out.println("\n=== 12. Binary Search (List must be sorted) ===");
       // Binary Search requires sorted list - O(log n) complexity
       Collections.sort(footballers);
       int index = Collections.binarySearch(footballers, "Kevin De Bruyne");
       if (index >= 0) {
           System.out.println("Found 'Kevin De Bruyne' at index: " + index);
       } else {
           System.out.println("Not found. Insertion point: " + (-(index + 1)));
       }

       System.out.println("\n=== 13. Frequency of an Element ===");
       // Counts occurrences of specified element - O(n) complexity
       int frequency = Collections.frequency(footballers, "Kevin De Bruyne");
       System.out.println("Frequency of 'Kevin De Bruyne': " + frequency);

       
       // 6. SET OPERATIONS
       

       System.out.println("\n=== 14. Checking if Two Lists are Disjoint ===");
       // Returns true if two collections have no common elements
       List<String> newFootballers = Arrays.asList("Rishabh Pant", "Shubhman Gill", "Kevin De Bruyne");
       boolean noCommonElements = Collections.disjoint(footballers, newFootballers);
       System.out.println("No common elements: " + noCommonElements);

       // ============================================
       // 7. COPYING & FILLING
       // ============================================

       System.out.println("\n=== 15. Copying Elements ===");
       // Destination list must be at least as long as source list
       // Creates list with empty strings, then copies source to dest
       List<String> copyFootballers = new ArrayList<>(Collections.nCopies(footballers.size(), ""));
       Collections.copy(copyFootballers, footballers);
       System.out.println("Copied " + copyFootballers.size() + " elements");

       System.out.println("\n=== 16. Replacing All Elements with a Single Value ===");
       // Collections.fill() replaces all elements with specified value
       List<String> replaceList = new ArrayList<>(footballers);
       Collections.fill(replaceList, "Unknown Player");
       System.out.println("First 3 after fill: " + replaceList.subList(0, 3));

       System.out.println("\n=== 17. Adding Multiple Elements (addAll) ===");
       // Collections.addAll() is more efficient than multiple add() calls
       List<String> combinedList = new ArrayList<>(footballers);
       Collections.addAll(combinedList, "Lionel Messi", "Cristiano Ronaldo", "Neymar Jr");
       System.out.println("Total players after adding: " + combinedList.size());

       // ============================================
       // 8. FAIL-FAST vs FAIL-SAFE ITERATORS
       // ============================================

       System.out.println("\n=== 18. Fail-Fast Iterator Example ===");
       // Most Java collections (ArrayList, HashMap, HashSet) are FAIL-FAST
       // Throw ConcurrentModificationException if collection modified during iteration
       try {
           List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
           for (Integer num : numbers) {
               System.out.print(num + " ");
               if (num == 3) {
                   numbers.add(10); // This will throw ConcurrentModificationException
               }
           }
       } catch (ConcurrentModificationException e) {
           System.out.println("\n✗ ConcurrentModificationException caught (Fail-Fast behavior)");
       }

       System.out.println("\n=== 19. Fail-Safe Iterator Example ===");
       // Concurrent collections (CopyOnWriteArrayList, ConcurrentHashMap) are FAIL-SAFE
       // Work on a snapshot/clone - modifications during iteration are allowed
       CopyOnWriteArrayList<String> safeList = new CopyOnWriteArrayList<>(Arrays.asList("A", "B", "C"));
       for (String item : safeList) {
           System.out.print(item + " ");
           if (item.equals("B")) {
               safeList.add("D"); // No exception thrown
           }
       }
       System.out.println("\n✓ No exception - Fail-Safe behavior");
       System.out.println("Final list: " + safeList);

       // ============================================
       // 9. LIST vs SET vs MAP
       // ============================================

       System.out.println("\n=== 20. List vs Set vs Map Comparison ===");
       
       // LIST: Ordered, allows duplicates, indexed access
       List<String> playerList = new ArrayList<>();
       playerList.add("Messi");
       playerList.add("Messi"); // Duplicate allowed
       System.out.println("List (allows duplicates): " + playerList);

       // SET: No duplicates, no guaranteed order (HashSet), no index
       Set<String> playerSet = new HashSet<>();
       playerSet.add("Messi");
       playerSet.add("Messi"); // Duplicate ignored
       System.out.println("Set (no duplicates): " + playerSet);

       // MAP: Key-Value pairs, no duplicate keys
       Map<String, Integer> playerGoals = new HashMap<>();
       playerGoals.put("Messi", 800);
       playerGoals.put("Ronaldo", 850);
       System.out.println("Map (key-value): " + playerGoals);

       // ============================================
       // 10. IMPORTANT COLLECTION METHODS
       // ============================================

       System.out.println("\n=== 21. Important List Methods ===");
       List<String> demoList = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
       
       // subList() returns a view (changes reflect in original)
       List<String> subList = demoList.subList(1, 4); // From index 1 to 3 (4 exclusive)
       System.out.println("SubList (1-3): " + subList);
       
       // replaceAll() with lambda
       demoList.replaceAll(String::toLowerCase);
       System.out.println("After replaceAll: " + demoList);
       
       // removeIf() with predicate
       demoList.removeIf(s -> s.equals("c"));
       System.out.println("After removeIf: " + demoList);

       // ============================================
       // 11. PERFORMANCE COMPARISON
       // ============================================

       System.out.println("\n=== 22. ArrayList vs LinkedList Performance ===");
       
       // ArrayList: Fast random access O(1), slow insertion/deletion O(n)
       List<Integer> arrayList = new ArrayList<>();
       long start = System.nanoTime();
       for (int i = 0; i < 10000; i++) {
           arrayList.add(i);
       }
       long arrayListTime = System.nanoTime() - start;
       
       // LinkedList: Slow random access O(n), fast insertion/deletion O(1)
       List<Integer> linkedList = new LinkedList<>();
       start = System.nanoTime();
       for (int i = 0; i < 10000; i++) {
           linkedList.add(i);
       }
       long linkedListTime = System.nanoTime() - start;
       
       System.out.println("ArrayList add time: " + arrayListTime + " ns");
       System.out.println("LinkedList add time: " + linkedListTime + " ns");

       // ============================================
       // 12. HASHMAP vs TREEMAP vs LINKEDHASHMAP
       // ============================================

       System.out.println("\n=== 23. Map Implementations Comparison ===");
       
       // HashMap: No order, O(1) operations, allows null key
       Map<String, Integer> hashMap = new HashMap<>();
       hashMap.put("Messi", 35);
       hashMap.put("Ronaldo", 38);
       hashMap.put("Neymar", 31);
       System.out.println("HashMap (no order): " + hashMap.keySet());
       
       // TreeMap: Sorted by keys, O(log n) operations, no null key
       Map<String, Integer> treeMap = new TreeMap<>();
       treeMap.put("Messi", 35);
       treeMap.put("Ronaldo", 38);
       treeMap.put("Neymar", 31);
       System.out.println("TreeMap (sorted): " + treeMap.keySet());
       
       // LinkedHashMap: Maintains insertion order, slightly slower than HashMap
       Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
       linkedHashMap.put("Messi", 35);
       linkedHashMap.put("Ronaldo", 38);
       linkedHashMap.put("Neymar", 31);
       System.out.println("LinkedHashMap (insertion order): " + linkedHashMap.keySet());

       // ============================================
       // 13. STREAM API WITH COLLECTIONS
       // ============================================

       System.out.println("\n=== 24. Stream API Examples ===");
       
       Collections.sort(footballers); // Sort first for demo
       
       // Filter and collect
       List<String> longNames = footballers.stream()
           .filter(name -> name.length() > 12)
           .collect(Collectors.toList());
       System.out.println("Players with name > 12 chars: " + longNames.size());
       
       // Map and collect
       List<Integer> nameLengths = footballers.stream()
           .map(String::length)
           .collect(Collectors.toList());
       System.out.println("Name lengths: " + nameLengths.subList(0, 5) + "...");
       
       // Count with condition
       long count = footballers.stream()
           .filter(name -> name.contains("a"))
           .count();
       System.out.println("Names with letter 'a': " + count);

       // ============================================
       // 14. QUEUE & DEQUE OPERATIONS
       // ============================================

       System.out.println("\n=== 25. Queue Operations (FIFO) ===");
       
       // Queue: First-In-First-Out (FIFO)
       Queue<String> queue = new LinkedList<>();
       queue.offer("First");  // Add to rear
       queue.offer("Second");
       queue.offer("Third");
       System.out.println("Queue: " + queue);
       System.out.println("Peek (front): " + queue.peek()); // View front without removing
       System.out.println("Poll (remove): " + queue.poll()); // Remove and return front
       System.out.println("After poll: " + queue);

       System.out.println("\n=== 26. Deque Operations (Double-Ended Queue) ===");
       
       // Deque: Can add/remove from both ends
       Deque<String> deque = new ArrayDeque<>();
       deque.addFirst("Front");
       deque.addLast("Back");
       deque.addFirst("New Front");
       System.out.println("Deque: " + deque);
       System.out.println("Remove first: " + deque.removeFirst());
       System.out.println("Remove last: " + deque.removeLast());
       System.out.println("After removals: " + deque);

       // ============================================
       // 15. IMPORTANT INTERVIEW CONCEPTS
       // ============================================

       System.out.println("\n=== 27. Comparable vs Comparator ===");
       
       // Comparable: Natural ordering (implements in the class itself)
       // Comparator: Custom ordering (external to the class)
       
       List<Integer> nums = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9));
       Collections.sort(nums); // Uses Comparable (Integer implements Comparable)
       System.out.println("Natural order: " + nums);
       
       Collections.sort(nums, Comparator.reverseOrder()); // Uses Comparator
       System.out.println("Custom order: " + nums);

       System.out.println("\n=== 28. Singleton, Empty, and Checked Collections ===");
       
       // Singleton: Immutable collection with single element
       Set<String> singletonSet = Collections.singleton("OnlyElement");
       System.out.println("Singleton set: " + singletonSet);
       
       // Empty: Immutable empty collections
       List<String> emptyList = Collections.emptyList();
       System.out.println("Empty list size: " + emptyList.size());
       
       // Checked: Type-safe collection that throws exception on wrong type
       List<String> checkedList = Collections.checkedList(new ArrayList<>(), String.class);
       checkedList.add("Valid String");
       System.out.println("Checked list: " + checkedList);

       System.out.println("\n=== 29. Converting Between Collection Types ===");
       
       List<String> list = Arrays.asList("A", "B", "C", "A");
       
       // List to Set (removes duplicates)
       Set<String> set = new HashSet<>(list);
       System.out.println("List to Set: " + set);
       
       // Set back to List
       List<String> listFromSet = new ArrayList<>(set);
       System.out.println("Set to List: " + listFromSet);
       
       // List to Array
       String[] array = list.toArray(new String[0]);
       System.out.println("List to Array: " + Arrays.toString(array));
       
       // Array to List
       List<String> listFromArray = Arrays.asList(array);
       System.out.println("Array to List: " + listFromArray);

       // ============================================
       // 16. HASHSET vs TREESET vs LINKEDHASHSET
       // ============================================

       System.out.println("\n=== 30. Set Implementations Comparison ===");
       
       // HashSet: No order, O(1) operations, allows null
       Set<String> hashSet = new HashSet<>();
       hashSet.add("Messi");
       hashSet.add("Ronaldo");
       hashSet.add("Neymar");
       hashSet.add("Benzema");
       System.out.println("HashSet (no order): " + hashSet);
       
       // TreeSet: Sorted order, O(log n) operations, no null
       Set<String> treeSet = new TreeSet<>();
       treeSet.add("Messi");
       treeSet.add("Ronaldo");
       treeSet.add("Neymar");
       treeSet.add("Benzema");
       System.out.println("TreeSet (sorted): " + treeSet);
       
       // LinkedHashSet: Insertion order, O(1) operations, allows null
       Set<String> linkedHashSet = new LinkedHashSet<>();
       linkedHashSet.add("Messi");
       linkedHashSet.add("Ronaldo");
       linkedHashSet.add("Neymar");
       linkedHashSet.add("Benzema");
       System.out.println("LinkedHashSet (insertion order): " + linkedHashSet);

       // ============================================
       // 17. HASHMAP INTERNAL WORKING
       // ============================================

       System.out.println("\n=== 31. HashMap Internal Working ===");
       
       Map<String, Integer> playerMap = new HashMap<>();
       playerMap.put("Messi", 10);
       playerMap.put("Ronaldo", 7);
       
       // Key concepts:
       System.out.println("HashMap uses:");
       System.out.println("- Array of buckets (default size: 16)");
       System.out.println("- hashCode() to find bucket index");
       System.out.println("- equals() to compare keys in same bucket");
       System.out.println("- Load factor: 0.75 (rehashes at 75% capacity)");
       System.out.println("- Java 8+: Uses trees instead of linked lists when bucket size > 8");
       System.out.println("- putIfAbsent: " + playerMap.putIfAbsent("Neymar", 11));
       System.out.println("- getOrDefault: " + playerMap.getOrDefault("Haaland", 0));
       System.out.println("- computeIfAbsent: " + playerMap.computeIfAbsent("Mbappe", k -> 29));

       // ============================================
       // 18. CONCURRENT COLLECTIONS
       // ============================================

       System.out.println("\n=== 32. Concurrent Collections (Thread-Safe) ===");
       
       // ConcurrentHashMap: Thread-safe, no locking on entire map
       Map<String, Integer> concurrentMap = new java.util.concurrent.ConcurrentHashMap<>();
       concurrentMap.put("Key1", 1);
       concurrentMap.put("Key2", 2);
       System.out.println("ConcurrentHashMap: Segment-level locking, better performance");
       
       // CopyOnWriteArrayList: Thread-safe, creates copy on modification
       List<String> cowList = new CopyOnWriteArrayList<>(Arrays.asList("A", "B"));
       System.out.println("CopyOnWriteArrayList: Good for read-heavy operations");
       
       System.out.println("\nConcurrent vs Synchronized:");
       System.out.println("- Synchronized: Locks entire collection (slow)");
       System.out.println("- Concurrent: Segment/bucket level locking (fast)");

       // ============================================
       // 19. VECTOR vs ARRAYLIST
       // ============================================

       System.out.println("\n=== 33. Vector vs ArrayList ===");
       
       List<String> vector = new Vector<>();
       vector.add("Item1");
       List<String> arrayListDemo = new ArrayList<>();
       arrayListDemo.add("Item1");
       
       System.out.println("Vector:");
       System.out.println("- Synchronized (thread-safe but slower)");
       System.out.println("- Legacy class (since JDK 1.0)");
       System.out.println("- Grows by 100% (doubles in size)");
       System.out.println("\nArrayList:");
       System.out.println("- Not synchronized (faster)");
       System.out.println("- Modern (since JDK 1.2)");
       System.out.println("- Grows by 50%");

       // ============================================
       // 20. PRIORITYQUEUE (HEAP)
       // ============================================

       System.out.println("\n=== 34. PriorityQueue (Min-Heap by default) ===");
       
       // Min-heap: smallest element has highest priority
       Queue<Integer> minHeap = new java.util.PriorityQueue<>();
       minHeap.offer(5);
       minHeap.offer(2);
       minHeap.offer(8);
       minHeap.offer(1);
       System.out.println("Min-Heap: " + minHeap);
       System.out.println("Peek (min): " + minHeap.peek());
       
       // Max-heap: largest element has highest priority
       Queue<Integer> maxHeap = new java.util.PriorityQueue<>(Collections.reverseOrder());
       maxHeap.offer(5);
       maxHeap.offer(2);
       maxHeap.offer(8);
       maxHeap.offer(1);
       System.out.println("Max-Heap peek (max): " + maxHeap.peek());

       // ============================================
       // 21. NAVIGABLE SET & MAP
       // ============================================

       System.out.println("\n=== 35. NavigableSet and NavigableMap ===");
       
       // NavigableSet: TreeSet implements this
       java.util.NavigableSet<Integer> navSet = new TreeSet<>(Arrays.asList(10, 20, 30, 40, 50));
       System.out.println("NavigableSet: " + navSet);
       System.out.println("lower(30): " + navSet.lower(30));     // < 30
       System.out.println("floor(30): " + navSet.floor(30));     // <= 30
       System.out.println("ceiling(25): " + navSet.ceiling(25)); // >= 25
       System.out.println("higher(30): " + navSet.higher(30));   // > 30
       
       // NavigableMap: TreeMap implements this
       java.util.NavigableMap<String, Integer> navMap = new TreeMap<>();
       navMap.put("A", 1);
       navMap.put("C", 3);
       navMap.put("E", 5);
       System.out.println("firstEntry: " + navMap.firstEntry());
       System.out.println("lastEntry: " + navMap.lastEntry());
       System.out.println("subMap(A to D): " + navMap.subMap("A", "D"));

       // ============================================
       // 22. WEAKHASHMAP
       // ============================================

       System.out.println("\n=== 36. WeakHashMap (For Cache Implementation) ===");
       
       // Keys are stored as weak references - GC can remove entries
       Map<String, String> weakMap = new java.util.WeakHashMap<>();
       String key1 = new String("Key1");
       String key2 = new String("Key2");
       weakMap.put(key1, "Value1");
       weakMap.put(key2, "Value2");
       System.out.println("WeakHashMap size before GC: " + weakMap.size());
       
       key1 = null; // Remove strong reference
       System.gc(); // Suggest garbage collection
       
       System.out.println("Used for memory-sensitive caches");
       System.out.println("Entries removed when keys are GC'd");

       // ============================================
       // 23. IDENTITY HASHMAP
       // ============================================

       System.out.println("\n=== 37. IdentityHashMap (Uses == instead of equals) ===");
       
       Map<String, Integer> identityMap = new java.util.IdentityHashMap<>();
       String s1 = new String("Key");
       String s2 = new String("Key");
       
       identityMap.put(s1, 1);
       identityMap.put(s2, 2);
       System.out.println("IdentityHashMap size: " + identityMap.size()); // 2, not 1!
       System.out.println("Uses reference equality (==), not equals()");

       // ============================================
       // 24. ENUM SET & ENUM MAP
       // ============================================

       System.out.println("\n=== 38. EnumSet and EnumMap (Optimized for Enums) ===");
       
       enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY }
       
       // EnumSet: Very efficient, uses bit vector internally
       EnumSet<Day> weekend = EnumSet.of(Day.FRIDAY);
       EnumSet<Day> weekdays = EnumSet.range(Day.MONDAY, Day.THURSDAY);
       System.out.println("EnumSet (weekdays): " + weekdays);
       
       // EnumMap: Fast, compact
       java.util.EnumMap<Day, String> enumMap = new java.util.EnumMap<>(Day.class);
       enumMap.put(Day.MONDAY, "Start of week");
       System.out.println("EnumMap: " + enumMap);

       // ============================================
       // 25. COLLECTION INTERFACE HIERARCHY
       // ============================================

       System.out.println("\n=== 39. Collection Interface Hierarchy ===");
       System.out.println("Collection (I)");
       System.out.println("├── List (I) - ArrayList, LinkedList, Vector, Stack");
       System.out.println("├── Set (I)");
       System.out.println("│   ├── HashSet");
       System.out.println("│   ├── LinkedHashSet");
       System.out.println("│   └── SortedSet (I) - TreeSet");
       System.out.println("└── Queue (I)");
       System.out.println("    ├── PriorityQueue");
       System.out.println("    └── Deque (I) - ArrayDeque, LinkedList");
       System.out.println("\nMap (I) - Separate hierarchy");
       System.out.println("├── HashMap, LinkedHashMap");
       System.out.println("├── SortedMap (I) - TreeMap");
       System.out.println("├── WeakHashMap, IdentityHashMap");
       System.out.println("└── ConcurrentHashMap");

       // ============================================
       // 26. IMPORTANT TIME COMPLEXITIES
       // ============================================

       System.out.println("\n=== 40. Time Complexity Cheat Sheet ===");
       System.out.println("ArrayList:");
       System.out.println("  get(i): O(1) | add(e): O(1)* | add(i,e): O(n) | remove(i): O(n)");
       System.out.println("LinkedList:");
       System.out.println("  get(i): O(n) | add(e): O(1) | add(i,e): O(n) | remove(i): O(n)");
       System.out.println("HashSet/HashMap:");
       System.out.println("  add/put: O(1)* | contains/get: O(1)* | remove: O(1)*");
       System.out.println("TreeSet/TreeMap:");
       System.out.println("  add/put: O(log n) | contains/get: O(log n) | remove: O(log n)");
       System.out.println("PriorityQueue:");
       System.out.println("  offer: O(log n) | poll: O(log n) | peek: O(1)");
       System.out.println("* Amortized time complexity");

       // ============================================
       // 27. EQUALS AND HASHCODE CONTRACT
       // ============================================

       System.out.println("\n=== 41. equals() and hashCode() Contract ===");
       System.out.println("1. If a.equals(b) is true, then a.hashCode() == b.hashCode()");
       System.out.println("2. If a.hashCode() == b.hashCode(), a.equals(b) may be


       // ============================================
       // 27. EQUALS AND HASHCODE CONTRACT (continued)
       // ============================================

       System.out.println("\n=== 41. equals() and hashCode() Contract (continued) ===");
       System.out.println("1. If a.equals(b) is true, then a.hashCode() == b.hashCode().");
       System.out.println("2. If a.hashCode() == b.hashCode(), a.equals(b) may be true or false (hash collisions).");
       System.out.println("3. hashCode() must consistently return the same value while the object is unchanged.");
       System.out.println("4. Use all fields used in equals() when calculating hashCode().");
       System.out.println("5. Prefer Objects.equals(a,b) to avoid NPEs in equals() implementations.");
       System.out.println("6. If overriding equals(), always override hashCode() as well.");

       // Practical examples and tips:
       System.out.println("\n=== Practical Tips / Best Practices ===");
       System.out.println("- Use IDE-generated equals() and hashCode() or Objects.hash(...) for correctness.");
       System.out.println("- Keep equals() symmetric, reflexive, transitive, and consistent.");
       System.out.println("- Make key fields immutable when objects are used as Map keys or Set elements.");
       System.out.println("- Avoid including mutable collection references in equals/hashCode unless necessary.");
       System.out.println("- If performance matters, cache hashCode for immutable objects (careful with memory).");
       System.out.println("- Document the equality semantics for your class (which fields are considered).");

       // Quick helper snippet demonstration (not modifying existing classes)
       System.out.println("\nExample (pseudo):");
       System.out.println("class Person {");
       System.out.println("  private final String id; // immutable unique id used for equals/hashCode");
       System.out.println("  @Override public boolean equals(Object o) { /* compare id */ }");
       System.out.println("  @Override public int hashCode() { return Objects.hash(id); }");
       System.out.println("}");

       // TODOs / Suggestions for repo:
       System.out.println("\n=== TODOs (for this repo) ===");
       System.out.println("- Add unit tests validating equals/hashCode for domain model classes.");
       System.out.println("- Add a coding guideline doc (e.g., CONTRIBUTING.md) that covers equals/hashCode rules.");
       System.out.println("- Consider static analysis (SpotBugs/Checkstyle) rules to detect bad implementations.");
